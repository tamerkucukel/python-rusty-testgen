# Python Rusty TestGen

<p align="center">
  <img src="static/logo-tk.svg" alt="Python Rusty TestGen Logo" width="200"/>
</p>

Python Rusty TestGen is a command-line tool written in Rust that automatically generates `pytest` unit tests for Python functions. It analyzes Python code, explores execution paths, and uses the Z3 SMT solver to determine input values that cover these paths, then generates test cases based on this analysis.

## Overview

The primary goal of this project is to reduce the manual effort involved in writing unit tests by automatically generating test cases that cover different logical paths within Python functions. It leverages static analysis techniques and an SMT solver to achieve this.

## Features

*   **AST-based Analysis:** Parses Python code into an Abstract Syntax Tree for detailed inspection.
*   **Control Flow Graph (CFG) Generation:** Builds a CFG for each function to understand its structure and execution flows.
*   **Path Exploration:** Identifies distinct execution paths through the CFG.
*   **SMT Solver Integration (Z3):**
    *   Generates logical constraints for each path.
    *   Uses Z3 to find satisfying input models (values for function arguments) for these paths.
*   **Pytest Test Generation:**
    *   Creates `pytest` test functions based on the Z3 models.
    *   Handles various data types for arguments and return values (`int`, `bool`, `str`, `float`).
    *   Supports assertions for return values, including `pytest.approx` for floating-point comparisons.
    *   Generates tests for paths leading to `raise` statements using `pytest.raises`.
    *   Handles explicit and implicit `None` returns.
    *   Supports chained comparisons (e.g., `a < b <= c`).
*   **Logging:** Provides verbose logging (`testgen.log`) and CFG details (`cfg_details.log`).

## How it Works (High-Level Workflow)

1.  **Load AST:** The input Python file is parsed into an Abstract Syntax Tree (AST).
2.  **Build CFG:** For each function definition in the AST, a Control Flow Graph (CFG) is constructed.
3.  **Explore Paths:** The CFG is traversed to identify all unique execution paths from the function's entry to its exit points (return or raise statements).
4.  **Generate Constraints & Solve:**
    *   For each path, a set of logical constraints is generated. These constraints represent the conditions that must be true for that specific path to be taken.
    *   The Z3 SMT solver is used to find a model (a set of input values for the function's arguments) that satisfies these constraints.
5.  **Generate Tests:**
    *   If Z3 finds a satisfiable model for a path, a `pytest` test case is generated.
    *   The model values are used as inputs for the function call in the test.
    *   The expected outcome (return value or raised exception) for that path is asserted.
6.  **Output:** The generated tests are written to `test_generated_suite.py`.

## Prerequisites

*   **Rust Toolchain:** Ensure you have Rust installed (see [rustup.rs](https://rustup.rs/)).
*   **Z3 SMT Solver:** Z3 must be installed and accessible in your system's `PATH` or its library files available for linking. You can download Z3 from its [GitHub releases page](https://github.com/Z3Prover/z3/releases).
*   **Python Environment:** A Python environment with `pytest` installed is needed to run the generated tests.
    ```bash
    pip install pytest
    ```

## Building the Project

1.  Clone the repository:
    ```bash
    git clone <repository-url>
    cd python-rusty-testgen
    ```
2.  Build the project:
    *   For a development build:
        ```bash
        cargo build
        ```
    *   For a release build (recommended for usage):
        ```bash
        cargo build --release
        ```
    The executable will be located at `target/debug/python-rusty-testgen` or `target/release/python-rusty-testgen`.

## Usage

Run the tool from the command line, providing the path to the Python file you want to analyze.

```bash
./target/release/python-rusty-testgen <path_to_your_python_file.py>
```

**Command-line Arguments:**

*   `<PYTHON_FILE>`: (Required) The Python file to generate tests for.
*   `-q, --quiet`: Suppress verbose output to the console. Errors will still be printed. Verbose logging to files (`testgen.log`, `cfg_details.log`) will still occur.

**Example:**

If you have a Python file named `my_module.py` in the current directory:
```bash
./target/release/python-rusty-testgen my_module.py
```

Or, if it's in a subdirectory:
```bash
./target/release/python-rusty-testgen examples/another_file.py
```

## Output Files

When you run the tool, it will generate the following files in the current working directory:

*   **`test_generated_suite.py`**: This file contains the `pytest` unit tests generated by the tool. You can run these tests using:
    ```bash
    pytest test_generated_suite.py
    ```
*   **`testgen.log`**: This file contains verbose logging output from the tool's execution. It includes details about:
    *   AST loading.
    *   CFG construction steps.
    *   Paths explored.
    *   Z3 models found (or unsatisfiability).
    *   Any errors or warnings encountered during processing.
    This log is useful for debugging and understanding the tool's behavior.
*   **`cfg_details.log`**: This file provides a textual representation of the Control Flow Graph for each function processed. It lists the nodes and edges, which can help in visualizing the function's structure as understood by the tool.

## Limitations and Future Work

While Python Rusty TestGen aims to automate test generation, it currently has some limitations:

*   **Complex Data Structures:** Support for generating inputs and constraints for complex data structures like lists, dictionaries, sets, and custom objects is limited. The tool primarily focuses on primitive types (`int`, `float`, `bool`, `str`).
*   **Loops:** Path exploration through loops might be bounded or simplified to avoid an infinite number of paths. The current strategy might unroll loops a fixed number of times or not explore all possible iteration counts.
*   **External Calls & I/O:** The tool does not model or mock external library calls, file I/O, network requests, or other side effects. Functions heavily reliant on such operations might not have comprehensive tests generated for those interactions.
*   **Python Feature Coverage:** While it covers common Python constructs, some advanced or very dynamic Python features might not be fully supported or translated into Z3 constraints accurately.
*   **Type Hint Reliance:** The tool relies heavily on Python type hints for function arguments to determine the correct Z3 variable sorts (e.g., `Int`, `Real`, `Bool`). Functions without type hints, or with complex/unsupported type hints, may have limited or no tests generated.
*   **String Constraints:** Generation of meaningful string constraints beyond simple equality or fixed values is limited.
*   **Floating Point Precision:** While `pytest.approx` is used, complex sequences of floating-point operations might still lead to precision issues between Z3's real arithmetic and Python's float arithmetic in edge cases.

**Potential Future Enhancements:**

*   Improved handling of loops (e.g., configurable unrolling, symbolic loop analysis).
*   Basic support for simple list/dict inputs.
*   User-configurable options for path exploration depth or timeout for Z3.
*   Strategies for handling functions with no type hints (e.g., type inference or user-provided defaults).
*   Support for generating tests for specific classes or methods within a file.
*   Integration with mocking frameworks to handle external dependencies.
*   More sophisticated string constraint generation.

## Contributing

Contributions are welcome! If you'd like to contribute, please feel free to fork the repository, make your changes, and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

## License

This project is licensed under the MIT License.